-1 	0 -1 	0:Source:dominion.c
-1 	0:Graph:dominion.gcno
-1 	0:Data:dominion.gcda
-1 	0:Runs:1
-1 	0:Programs:1
-1 	1:#include "dominion.h"
-1 	2:#include "dominion_helpers.h"
-1 	3:#include "rngs.h"
-1 	4:#include <stdio.h>
-1 	5:#include <math.h>
-1 	6:#include <stdlib.h>
-1 	7:
-1 	8:int compare(const void* a, const void* b) {
-1 	9:  if (*(int*)a > *(int*)b)
-1 	10:    return 1;
-1 	11:  if (*(int*)a < *(int*)b)
-1 	12:    return -1;
-1 	13:  return 0;
-1 	14:}
-1 	15:
-1 	16:struct gameState* newGame() {
-1 	17:  struct gameState* g = malloc(sizeof(struct gameState));
-1 	18:  return g;
-1 	19:}
-1 	20:
-1 	21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
-1 	22:		  int k8, int k9, int k10) {
-1 	23:  int* k = malloc(10 * sizeof(int));
-1 	24:  k[0] = k1;
-1 	25:  k[1] = k2;
-1 	26:  k[2] = k3;
-1 	27:  k[3] = k4;
-1 	28:  k[4] = k5;
-1 	29:  k[5] = k6;
-1 	30:  k[6] = k7;
-1 	31:  k[7] = k8;
-1 	32:  k[8] = k9;
-1 	33:  k[9] = k10;
-1 	34:  return k;
-1 	35:}
-1 	36:
-1 	37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
-1 	38:		   struct gameState *state) {
-1 	39:
-1 	40:  int i;
-1 	41:  int j;
-1 	42:  int it;			
-1 	43:  //set up random number generator
-1 	44:  SelectStream(1);
-1 	45:  PutSeed((long)randomSeed);
-1 	46:  
-1 	47:  //check number of players
-1 	48:  if (numPlayers > MAX_PLAYERS || numPlayers < 2)
-1 	49:    {
-1 	50:      return -1;
-1 	51:    }
-1 	52:
-1 	53:  //set number of players
-1 	54:  state->numPlayers = numPlayers;
-1 	55:
-1 	56:  //check selected kingdom cards are different
-1 	57:  for (i = 0; i < 10; i++)
-1 	58:    {
-1 	59:      for (j = 0; j < 10; j++)
-1 	60:        {
-1 	61:	  if (j != i && kingdomCards[j] == kingdomCards[i])
-1 	62:	    {
-1 	63:	      return -1;
-1 	64:	    }
-1 	65:        }
-1 	66:    }
-1 	67:
-1 	68:
-1 	69:  //initialize supply
-1 	70:  ///////////////////////////////
-1 	71:
-1 	72:  //set number of Curse cards
-1 	73:  if (numPlayers == 2)
-1 	74:    {
-1 	75:      state->supplyCount[curse] = 10;
-1 	76:    }
-1 	77:  else if (numPlayers == 3)
-1 	78:    {
-1 	79:      state->supplyCount[curse] = 20;
-1 	80:    }
-1 	81:  else
-1 	82:    {
-1 	83:      state->supplyCount[curse] = 30;
-1 	84:    }
-1 	85:
-1 	86:  //set number of Victory cards
-1 	87:  if (numPlayers == 2)
-1 	88:    {
-1 	89:      state->supplyCount[estate] = 8;
-1 	90:      state->supplyCount[duchy] = 8;
-1 	91:      state->supplyCount[province] = 8;
-1 	92:    }
-1 	93:  else
-1 	94:    {
-1 	95:      state->supplyCount[estate] = 12;
-1 	96:      state->supplyCount[duchy] = 12;
-1 	97:      state->supplyCount[province] = 12;
-1 	98:    }
-1 	99:
-1 	100:  //set number of Treasure cards
-1 	101:  state->supplyCount[copper] = 60 - (7 * numPlayers);
-1 	102:  state->supplyCount[silver] = 40;
-1 	103:  state->supplyCount[gold] = 30;
-1 	104:
-1 	105:  //set number of Kingdom cards
-1 	106:  for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
-1 	107:    {
-1 	108:      for (j = 0; j < 10; j++)           		//loop chosen cards
-1 	109:	{
-1 	110:	  if (kingdomCards[j] == i)
-1 	111:	    {
-1 	112:	      //check if card is a 'Victory' Kingdom card
-1 	113:	      if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
-1 	114:		{
-1 	115:		  if (numPlayers == 2){ 
-1 	116:		    state->supplyCount[i] = 8; 
-1 	117:		  }
-1 	118:		  else{ state->supplyCount[i] = 12; }
-1 	119:		}
-1 	120:	      else
-1 	121:		{
-1 	122:		  state->supplyCount[i] = 10;
-1 	123:		}
-1 	124:	      break;
-1 	125:	    }
-1 	126:	  else    //card is not in the set choosen for the game
-1 	127:	    {
-1 	128:	      state->supplyCount[i] = -1;
-1 	129:	    }
-1 	130:	}
-1 	131:
-1 	132:    }
-1 	133:
-1 	134:  ////////////////////////
-1 	135:  //supply intilization complete
-1 	136:
-1 	137:  //set player decks
-1 	138:  for (i = 0; i < numPlayers; i++)
-1 	139:    {
-1 	140:      state->deckCount[i] = 0;
-1 	141:      for (j = 0; j < 3; j++)
-1 	142:	{
-1 	143:	  state->deck[i][j] = estate;
-1 	144:	  state->deckCount[i]++;
-1 	145:	}
-1 	146:      for (j = 3; j < 10; j++)
-1 	147:	{
-1 	148:	  state->deck[i][j] = copper;
-1 	149:	  state->deckCount[i]++;		
-1 	150:	}
-1 	151:    }
-1 	152:
-1 	153:  //shuffle player decks
-1 	154:  for (i = 0; i < numPlayers; i++)
-1 	155:    {
-1 	156:      if ( shuffle(i, state) < 0 )
-1 	157:      {
-1 	158:	  return -1;
-1 	159:      }
-1 	160:    }
-1 	161:
-1 	162:  //draw player hands
-1 	163:  for (i = 0; i < numPlayers; i++)
-1 	164:    {  
-1 	165:      //initialize hand size to zero
-1 	166:      state->handCount[i] = 0;
-1 	167:      state->discardCount[i] = 0;
-1 	168:      //draw 5 cards
-1 	169:      // for (j = 0; j < 5; j++)
-1 	170:      //  {
-1 	171:      //      drawCard(i, state);
-1 	172:      //  }
-1 	173:    }
-1 	174:  
-1 	175:  //set embargo tokens to 0 for all supply piles
-1 	176:  for (i = 0; i <= treasure_map; i++)
-1 	177:    {
-1 	178:      state->embargoTokens[i] = 0;
-1 	179:    }
-1 	180:
-1 	181:  //initialize first player's turn
-1 	182:  state->outpostPlayed = 0;
-1 	183:  state->phase = 0;
-1 	184:  state->numActions = 1;
-1 	185:  state->numBuys = 1;
-1 	186:  state->playedCardCount = 0;
-1 	187:  state->whoseTurn = 0;
-1 	188:  state->handCount[state->whoseTurn] = 0;
-1 	189:  //int it; move to top
-1 	190:
-1 	191:  //Moved draw cards to here, only drawing at the start of a turn
-1 	192:  for (it = 0; it < 5; it++){
-1 	193:    drawCard(state->whoseTurn, state);
-1 	194:  }
-1 	195:
-1 	196:  updateCoins(state->whoseTurn, state, 0);
-1 	197:
-1 	198:  return 0;
-1 	199:}
-1 	200:
-1 	201:int shuffle(int player, struct gameState *state) {
-1 	202:
-1 	203: 
-1 	204:  int newDeck[MAX_DECK];
-1 	205:  int newDeckPos = 0;
-1 	206:  int card;
-1 	207:  int i;
-1 	208:
-1 	209:  if (state->deckCount[player] < 1)
-1 	210:    return -1;
-1 	211:  qsort ((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare); 
-1 	212:  /* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
-1 	213:
-1 	214:  while (state->deckCount[player] > 0) {
-1 	215:    card = floor(Random() * state->deckCount[player]);
-1 	216:    newDeck[newDeckPos] = state->deck[player][card];
-1 	217:    newDeckPos++;
-1 	218:    for (i = card; i < state->deckCount[player]-1; i++) {
-1 	219:      state->deck[player][i] = state->deck[player][i+1];
-1 	220:    }
-1 	221:    state->deckCount[player]--;
-1 	222:  }
-1 	223:  for (i = 0; i < newDeckPos; i++) {
-1 	224:    state->deck[player][i] = newDeck[i];
-1 	225:    state->deckCount[player]++;
-1 	226:  }
-1 	227:
-1 	228:  return 0;
-1 	229:}
-1 	230:
0.5 	231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state) 
-1 	232:{	
-1 	233:  int card;
0.5 	234:  int coin_bonus = 0; 		//tracks coins gain from actions
-1 	235:
-1 	236:  //check if it is the right phase
0.5 	237:  if (state->phase != 0)
-1 	238:    {
0.0 	239:      return -1;
-1 	240:    }
-1 	241:	
-1 	242:  //check if player has enough actions
0.844827586207 	243:  if ( state->numActions < 1 )
-1 	244:    {
0.0 	245:      return -1;
-1 	246:    }
-1 	247:	
-1 	248:  //get card played
0.871886120996 	249:  card = handCard(handPos, state);
-1 	250:	
-1 	251:  //check if selected card is an action
0.871886120996 	252:  if ( card < adventurer || card > treasure_map )
-1 	253:    {
-1 	254:      return -1;
-1 	255:    }
-1 	256:	
-1 	257:  //play card
0.871886120996 	258:  if ( cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0 )
-1 	259:    {
0.0 	260:      return -1;
-1 	261:    }
-1 	262:	
-1 	263:  //reduce number of actions
0.957498778701 	264:  state->numActions--;
-1 	265:
-1 	266:  //update coins (Treasure cards may be added with card draws)
0.957498778701 	267:  updateCoins(state->whoseTurn, state, coin_bonus);
-1 	268:	
0.957498778701 	269:  return 0;
-1 	270:}
-1 	271:
-1 	272:int buyCard(int supplyPos, struct gameState *state) {
-1 	273:  int who;
-1 	274:  if (DEBUG){
-1 	275:    printf("Entering buyCard...\n");
-1 	276:  }
-1 	277:
-1 	278:  // I don't know what to do about the phase thing.
-1 	279:
-1 	280:  who = state->whoseTurn;
-1 	281:
-1 	282:  if (state->numBuys < 1){
-1 	283:    if (DEBUG)
-1 	284:      printf("You do not have any buys left\n");
-1 	285:    return -1;
-1 	286:  } else if (supplyCount(supplyPos, state) <1){
-1 	287:    if (DEBUG)
-1 	288:      printf("There are not any of that type of card left\n");
-1 	289:    return -1;
-1 	290:  } else if (state->coins < getCost(supplyPos)){
-1 	291:    if (DEBUG) 
-1 	292:      printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
-1 	293:    return -1;
-1 	294:  } else {
-1 	295:    state->phase=1;
-1 	296:    //state->supplyCount[supplyPos]--;
-1 	297:    gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
-1 	298:  
-1 	299:    state->coins = (state->coins) - (getCost(supplyPos));
-1 	300:    state->numBuys--;
-1 	301:    if (DEBUG)
-1 	302:      printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
-1 	303:  }
-1 	304:
-1 	305:  //state->discard[who][state->discardCount[who]] = supplyPos;
-1 	306:  //state->discardCount[who]++;
-1 	307:    
-1 	308:  return 0;
-1 	309:}
-1 	310:
-1 	311:int numHandCards(struct gameState *state) {
-1 	312:  return state->handCount[ whoseTurn(state) ];
-1 	313:}
-1 	314:
0.871886120996 	315:int handCard(int handPos, struct gameState *state) {
0.871886120996 	316:  int currentPlayer = whoseTurn(state);
0.871886120996 	317:  return state->hand[currentPlayer][handPos];
-1 	318:}
-1 	319:
0.957498778701 	320:int supplyCount(int card, struct gameState *state) {
0.957498778701 	321:  return state->supplyCount[card];
-1 	322:}
-1 	323:
-1 	324:int fullDeckCount(int player, int card, struct gameState *state) {
-1 	325:  int i;
-1 	326:  int count = 0;
-1 	327:
-1 	328:  for (i = 0; i < state->deckCount[player]; i++)
-1 	329:    {
-1 	330:      if (state->deck[player][i] == card) count++;
-1 	331:    }
-1 	332:
-1 	333:  for (i = 0; i < state->handCount[player]; i++)
-1 	334:    {
-1 	335:      if (state->hand[player][i] == card) count++;
-1 	336:    }
-1 	337:
-1 	338:  for (i = 0; i < state->discardCount[player]; i++)
-1 	339:    {
-1 	340:      if (state->discard[player][i] == card) count++;
-1 	341:    }
-1 	342:
-1 	343:  return count;
-1 	344:}
-1 	345:
0.871886120996 	346:int whoseTurn(struct gameState *state) {
0.871886120996 	347:  return state->whoseTurn;
-1 	348:}
-1 	349:
-1 	350:int endTurn(struct gameState *state) {
-1 	351:  int k;
-1 	352:  int i;
-1 	353:  int currentPlayer = whoseTurn(state);
-1 	354:  
-1 	355:  //Discard hand
-1 	356:  for (i = 0; i < state->handCount[currentPlayer]; i++){
-1 	357:    state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
-1 	358:    state->hand[currentPlayer][i] = -1;//Set card to -1
-1 	359:  }
-1 	360:  state->handCount[currentPlayer] = 0;//Reset hand count
-1 	361:    
-1 	362:  //Code for determining the player
-1 	363:  if (currentPlayer < (state->numPlayers - 1)){ 
-1 	364:    state->whoseTurn = currentPlayer + 1;//Still safe to increment
-1 	365:  }
-1 	366:  else{
-1 	367:    state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
-1 	368:  }
-1 	369:
-1 	370:  state->outpostPlayed = 0;
-1 	371:  state->phase = 0;
-1 	372:  state->numActions = 1;
-1 	373:  state->coins = 0;
-1 	374:  state->numBuys = 1;
-1 	375:  state->playedCardCount = 0;
-1 	376:  state->handCount[state->whoseTurn] = 0;
-1 	377:
-1 	378:  //int k; move to top
-1 	379:  //Next player draws hand
-1 	380:  for (k = 0; k < 5; k++){
-1 	381:    drawCard(state->whoseTurn, state);//Draw a card
-1 	382:  }
-1 	383:
-1 	384:  //Update money
-1 	385:  updateCoins(state->whoseTurn, state , 0);
-1 	386:
-1 	387:  return 0;
-1 	388:}
-1 	389:
-1 	390:int isGameOver(struct gameState *state) {
-1 	391:  int i;
-1 	392:  int j;
-1 	393:	
-1 	394:  //if stack of Province cards is empty, the game ends
-1 	395:  if (state->supplyCount[province] == 0)
-1 	396:    {
-1 	397:      return 1;
-1 	398:    }
-1 	399:
-1 	400:  //if three supply pile are at 0, the game ends
-1 	401:  j = 0;
-1 	402:  for (i = 0; i < 25; i++)
-1 	403:    {
-1 	404:      if (state->supplyCount[i] == 0)
-1 	405:	{
-1 	406:	  j++;
-1 	407:	}
-1 	408:    }
-1 	409:  if ( j >= 3)
-1 	410:    {
-1 	411:      return 1;
-1 	412:    }
-1 	413:
-1 	414:  return 0;
-1 	415:}
-1 	416:
-1 	417:int scoreFor (int player, struct gameState *state) {
-1 	418:
-1 	419:  int i;
-1 	420:  int score = 0;
-1 	421:  //score from hand
-1 	422:  for (i = 0; i < state->handCount[player]; i++)
-1 	423:    {
-1 	424:      if (state->hand[player][i] == curse) { score = score - 1; };
-1 	425:      if (state->hand[player][i] == estate) { score = score + 1; };
-1 	426:      if (state->hand[player][i] == duchy) { score = score + 3; };
-1 	427:      if (state->hand[player][i] == province) { score = score + 6; };
-1 	428:      if (state->hand[player][i] == great_hall) { score = score + 1; };
-1 	429:      if (state->hand[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
-1 	430:    }
-1 	431:
-1 	432:  //score from discard
-1 	433:  for (i = 0; i < state->discardCount[player]; i++)
-1 	434:    {
-1 	435:      if (state->discard[player][i] == curse) { score = score - 1; };
-1 	436:      if (state->discard[player][i] == estate) { score = score + 1; };
-1 	437:      if (state->discard[player][i] == duchy) { score = score + 3; };
-1 	438:      if (state->discard[player][i] == province) { score = score + 6; };
-1 	439:      if (state->discard[player][i] == great_hall) { score = score + 1; };
-1 	440:      if (state->discard[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
-1 	441:    }
-1 	442:
-1 	443:  //score from deck
-1 	444:  for (i = 0; i < state->discardCount[player]; i++)
-1 	445:    {
-1 	446:      if (state->deck[player][i] == curse) { score = score - 1; };
-1 	447:      if (state->deck[player][i] == estate) { score = score + 1; };
-1 	448:      if (state->deck[player][i] == duchy) { score = score + 3; };
-1 	449:      if (state->deck[player][i] == province) { score = score + 6; };
-1 	450:      if (state->deck[player][i] == great_hall) { score = score + 1; };
-1 	451:      if (state->deck[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
-1 	452:    }
-1 	453:
-1 	454:  return score;
-1 	455:}
-1 	456:
-1 	457:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
-1 	458:  int i;	
-1 	459:  int j;
-1 	460:  int highScore;
-1 	461:  int currentPlayer;
-1 	462:
-1 	463:  //get score for each player
-1 	464:  for (i = 0; i < MAX_PLAYERS; i++)
-1 	465:    {
-1 	466:      //set unused player scores to -9999
-1 	467:      if (i >= state->numPlayers)
-1 	468:	{
-1 	469:	  players[i] = -9999;
-1 	470:	}
-1 	471:      else
-1 	472:	{
-1 	473:	  players[i] = scoreFor (i, state);
-1 	474:	}
-1 	475:    }
-1 	476:
-1 	477:  //find highest score
-1 	478:  j = 0;
-1 	479:  for (i = 0; i < MAX_PLAYERS; i++)
-1 	480:    {
-1 	481:      if (players[i] > players[j])
-1 	482:	{
-1 	483:	  j = i;
-1 	484:	}
-1 	485:    }
-1 	486:  highScore = players[j];
-1 	487:
-1 	488:  //add 1 to players who had less turns
-1 	489:  currentPlayer = whoseTurn(state);
-1 	490:  for (i = 0; i < MAX_PLAYERS; i++)
-1 	491:    {
-1 	492:      if ( players[i] == highScore && i > currentPlayer )
-1 	493:	{
-1 	494:	  players[i]++;
-1 	495:	}
-1 	496:    }
-1 	497:
-1 	498:  //find new highest score
-1 	499:  j = 0;
-1 	500:  for (i = 0; i < MAX_PLAYERS; i++)
-1 	501:    {
-1 	502:      if ( players[i] > players[j] )
-1 	503:	{
-1 	504:	  j = i;
-1 	505:	}
-1 	506:    }
-1 	507:  highScore = players[j];
-1 	508:
-1 	509:  //set winners in array to 1 and rest to 0
-1 	510:  for (i = 0; i < MAX_PLAYERS; i++)
-1 	511:    {
-1 	512:      if ( players[i] == highScore )
-1 	513:	{
-1 	514:	  players[i] = 1;
-1 	515:	}
-1 	516:      else
-1 	517:	{
-1 	518:	  players[i] = 0;
-1 	519:	}
-1 	520:    }
-1 	521:
-1 	522:  return 0;
-1 	523:}
-1 	524:
-1 	525:int drawCard(int player, struct gameState *state)
-1 	526:{	int count;
-1 	527:  int deckCounter;
-1 	528:  if (state->deckCount[player] <= 0){//Deck is empty
-1 	529:    
-1 	530:    //Step 1 Shuffle the discard pile back into a deck
-1 	531:    int i;
-1 	532:    //Move discard to deck
-1 	533:    for (i = 0; i < state->discardCount[player];i++){
-1 	534:      state->deck[player][i] = state->discard[player][i];
-1 	535:      state->discard[player][i] = -1;
-1 	536:    }
-1 	537:
-1 	538:    state->deckCount[player] = state->discardCount[player];
-1 	539:    state->discardCount[player] = 0;//Reset discard
-1 	540:
-1 	541:    //Shufffle the deck
-1 	542:    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
-1 	543:   
-1 	544:    if (DEBUG){//Debug statements
-1 	545:      printf("Deck count now: %d\n", state->deckCount[player]);
-1 	546:    }
-1 	547:    
-1 	548:    state->discardCount[player] = 0;
-1 	549:
-1 	550:    //Step 2 Draw Card
-1 	551:    count = state->handCount[player];//Get current player's hand count
-1 	552:    
-1 	553:    if (DEBUG){//Debug statements
-1 	554:      printf("Current hand count: %d\n", count);
-1 	555:    }
-1 	556:    
-1 	557:    deckCounter = state->deckCount[player];//Create a holder for the deck count
-1 	558:
-1 	559:    if (deckCounter == 0)
-1 	560:      return -1;
-1 	561:
-1 	562:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
-1 	563:    state->deckCount[player]--;
-1 	564:    state->handCount[player]++;//Increment hand count
-1 	565:  }
-1 	566:
-1 	567:  else{
-1 	568:    int count = state->handCount[player];//Get current hand count for player
-1 	569:    int deckCounter;
-1 	570:    if (DEBUG){//Debug statements
-1 	571:      printf("Current hand count: %d\n", count);
-1 	572:    }
-1 	573:
-1 	574:    deckCounter = state->deckCount[player];//Create holder for the deck count
-1 	575:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
-1 	576:    state->deckCount[player]--;
-1 	577:    state->handCount[player]++;//Increment hand count
-1 	578:  }
-1 	579:
-1 	580:  return 0;
-1 	581:}
-1 	582:
0.778086542279 	583:int getCost(int cardNumber)
-1 	584:{
0.778086542279 	585:  switch( cardNumber ) 
-1 	586:    {
-1 	587:    case curse:
1.0 	588:      return 0;
-1 	589:    case estate:
1.0 	590:      return 2;
-1 	591:    case duchy:
0.993243243243 	592:      return 5;
-1 	593:    case province:
0.942307692308 	594:      return 8;
-1 	595:    case copper:
0.485950413223 	596:      return 0;
-1 	597:    case silver:
0.696446700508 	598:      return 3;
-1 	599:    case gold:
0.760279286268 	600:      return 6;
-1 	601:    case adventurer:
0.960784313725 	602:      return 6;
-1 	603:    case council_room:
1.0 	604:      return 5;
-1 	605:    case feast:
1.0 	606:      return 4;
-1 	607:    case gardens:
-1 	608:      return 4;
-1 	609:    case mine:
1.0 	610:      return 5;
-1 	611:    case remodel:
1.0 	612:      return 4;
-1 	613:    case smithy:
1.0 	614:      return 4;
-1 	615:    case village:
1.0 	616:      return 3;
-1 	617:    case baron:
0.0 	618:      return 4;
-1 	619:    case great_hall:
-1 	620:      return 3;
-1 	621:    case minion:
0.0 	622:      return 5;
-1 	623:    case steward:
1.0 	624:      return 3;
-1 	625:    case tribute:
0.993243243243 	626:      return 5;
-1 	627:    case ambassador:
1.0 	628:      return 3;
-1 	629:    case cutpurse:
-1 	630:      return 4;
-1 	631:    case embargo: 
1.0 	632:      return 2;
-1 	633:    case outpost:
1.0 	634:      return 5;
-1 	635:    case salvager:
0.989898989899 	636:      return 4;
-1 	637:    case sea_hag:
0.0 	638:      return 4;
-1 	639:    case treasure_map:
1.0 	640:      return 4;
-1 	641:    }
-1 	642:	
-1 	643:  return -1;
-1 	644:}
-1 	645:
0.871886120996 	646:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
-1 	647:{
-1 	648:  int i;
-1 	649:  int j;
-1 	650:  int k;
-1 	651:  int x;
-1 	652:  int index;
0.871886120996 	653:  int currentPlayer = whoseTurn(state);
0.871886120996 	654:  int nextPlayer = currentPlayer + 1;
-1 	655:
0.871886120996 	656:  int tributeRevealedCards[2] = {-1, -1};
-1 	657:  int temphand[MAX_HAND];// moved above the if statement
0.871886120996 	658:  int drawntreasure=0;
-1 	659:  int cardDrawn;
0.871886120996 	660:  int z = 0;// this is the counter for the temp hand
0.871886120996 	661:  if (nextPlayer > (state->numPlayers - 1)){
0.854358974359 	662:    nextPlayer = 0;
-1 	663:  }
-1 	664:  
-1 	665:	
-1 	666:  //uses switch to select card and perform actions
0.871886120996 	667:  switch( card ) 
-1 	668:    {
-1 	669:    case adventurer:
-1 	670:       return adventurerEffect(state, handPos); 
-1 	671:			
-1 	672:    case council_room:
-1 	673:      //+4 Cards
-1 	674:      for (i = 0; i < 4; i++)
-1 	675:	{
-1 	676:	  drawCard(currentPlayer, state);
-1 	677:	}
-1 	678:			
-1 	679:      //+1 Buy
-1 	680:      state->numBuys++;
-1 	681:			
-1 	682:      //Each other player draws a card
-1 	683:      for (i = 0; i < state->numPlayers; i++)
-1 	684:	{
-1 	685:	  if ( i != currentPlayer )
-1 	686:	    {
-1 	687:	      drawCard(i, state);
-1 	688:	    }
-1 	689:	}
-1 	690:			
-1 	691:      //put played card in played card pile
-1 	692:      discardCard(handPos, currentPlayer, state, 0);
-1 	693:			
-1 	694:      return 0;
-1 	695:			
-1 	696:    case feast:
-1 	697:       return feastEffect(choice1, state, handPos);
-1 	698:			
-1 	699:    case gardens:
-1 	700:      return -1;
-1 	701:			
-1 	702:    case mine:
0.871886120996 	703:      return mineEffect(choice1, choice2, state, handPos);
-1 	704:			
-1 	705:    case remodel:
-1 	706:      j = state->hand[currentPlayer][choice1];  //store card we will trash
-1 	707:
-1 	708:      if ( (getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2) )
-1 	709:	{
-1 	710:	  return -1;
-1 	711:	}
-1 	712:
-1 	713:      gainCard(choice2, state, 0, currentPlayer);
-1 	714:
-1 	715:      //discard card from hand
-1 	716:      discardCard(handPos, currentPlayer, state, 0);
-1 	717:
-1 	718:      //discard trashed card
-1 	719:      for (i = 0; i < state->handCount[currentPlayer]; i++)
-1 	720:	{
-1 	721:	  if (state->hand[currentPlayer][i] == j)
-1 	722:	    {
-1 	723:	      discardCard(i, currentPlayer, state, 0);			
-1 	724:	      break;
-1 	725:	    }
-1 	726:	}
-1 	727:
-1 	728:
-1 	729:      return 0;
-1 	730:		
-1 	731:    case smithy:
-1 	732:      //+3 Cards
-1 	733:      return smithyEffect(state, handPos);
-1 	734:		
-1 	735:    case village:
-1 	736:      //+1 Card
-1 	737:      drawCard(currentPlayer, state);
-1 	738:			
-1 	739:      //+2 Actions
-1 	740:      state->numActions = state->numActions + 2;
-1 	741:			
-1 	742:      //discard played card from hand
-1 	743:      discardCard(handPos, currentPlayer, state, 0);
-1 	744:      return 0;
-1 	745:		
-1 	746:    case baron:
-1 	747:      state->numBuys++;//Increase buys by 1!
-1 	748:      if (choice1 > 0){//Boolean true or going to discard an estate
-1 	749:	int p = 0;//Iterator for hand!
-1 	750:	int card_not_discarded = 1;//Flag for discard set!
-1 	751:	while(card_not_discarded){
-1 	752:	  if (state->hand[currentPlayer][p] == estate){//Found an estate card!
-1 	753:	    state->coins += 4;//Add 4 coins to the amount of coins
-1 	754:	    state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
-1 	755:	    state->discardCount[currentPlayer]++;
-1 	756:	    for (;p < state->handCount[currentPlayer]; p++){
-1 	757:	      state->hand[currentPlayer][p] = state->hand[currentPlayer][p+1];
-1 	758:	    }
-1 	759:	    state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
-1 	760:	    state->handCount[currentPlayer]--;
-1 	761:	    card_not_discarded = 0;//Exit the loop
-1 	762:	  }
-1 	763:	  else if (p > state->handCount[currentPlayer]){
-1 	764:	    if(DEBUG) {
-1 	765:	      printf("No estate cards in your hand, invalid choice\n");
-1 	766:	      printf("Must gain an estate if there are any\n");
-1 	767:	    }
-1 	768:	    if (supplyCount(estate, state) > 0){
-1 	769:	      gainCard(estate, state, 0, currentPlayer);
-1 	770:	      state->supplyCount[estate]--;//Decrement estates
-1 	771:	      if (supplyCount(estate, state) == 0){
-1 	772:		isGameOver(state);
-1 	773:	      }
-1 	774:	    }
-1 	775:	    card_not_discarded = 0;//Exit the loop
-1 	776:	  }
-1 	777:			    
-1 	778:	  else{
-1 	779:	    p++;//Next card
-1 	780:	  }
-1 	781:	}
-1 	782:      }
-1 	783:			    
-1 	784:      else{
-1 	785:	if (supplyCount(estate, state) > 0){
-1 	786:	  gainCard(estate, state, 0, currentPlayer);//Gain an estate
-1 	787:	  state->supplyCount[estate]--;//Decrement Estates
-1 	788:	  if (supplyCount(estate, state) == 0){
-1 	789:	    isGameOver(state);
-1 	790:	  }
-1 	791:	}
-1 	792:      }
-1 	793:	    
-1 	794:      
-1 	795:      return 0;
-1 	796:		
-1 	797:    case great_hall:
-1 	798:      //+1 Card
-1 	799:      drawCard(currentPlayer, state);
-1 	800:			
-1 	801:      //+1 Actions
-1 	802:      state->numActions++;
-1 	803:			
-1 	804:      //discard card from hand
-1 	805:      discardCard(handPos, currentPlayer, state, 0);
-1 	806:      return 0;
-1 	807:		
-1 	808:    case minion:
-1 	809:      return minionEffect(choice1, choice2, state, handPos);
-1 	810:		
-1 	811:    case steward:
-1 	812:      if (choice1 == 1)
-1 	813:	{
-1 	814:	  //+2 cards
-1 	815:	  drawCard(currentPlayer, state);
-1 	816:	  drawCard(currentPlayer, state);
-1 	817:	}
-1 	818:      else if (choice1 == 2)
-1 	819:	{
-1 	820:	  //+2 coins
-1 	821:	  state->coins = state->coins + 2;
-1 	822:	}
-1 	823:      else
-1 	824:	{
-1 	825:	  //trash 2 cards in hand
-1 	826:	  discardCard(choice2, currentPlayer, state, 1);
-1 	827:	  discardCard(choice3, currentPlayer, state, 1);
-1 	828:	}
-1 	829:			
-1 	830:      //discard card from hand
-1 	831:      discardCard(handPos, currentPlayer, state, 0);
-1 	832:      return 0;
-1 	833:		
-1 	834:    case tribute:
-1 	835:      if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
-1 	836:	if (state->deckCount[nextPlayer] > 0){
-1 	837:	  tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
-1 	838:	  state->deckCount[nextPlayer]--;
-1 	839:	}
-1 	840:	else if (state->discardCount[nextPlayer] > 0){
-1 	841:	  tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer]-1];
-1 	842:	  state->discardCount[nextPlayer]--;
-1 	843:	}
-1 	844:	else{
-1 	845:	  //No Card to Reveal
-1 	846:	  if (DEBUG){
-1 	847:	    printf("No cards to reveal\n");
-1 	848:	  }
-1 	849:	}
-1 	850:      }
-1 	851:	    
-1 	852:      else{
-1 	853:	if (state->deckCount[nextPlayer] == 0){
-1 	854:	  for (i = 0; i < state->discardCount[nextPlayer]; i++){
-1 	855:	    state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
-1 	856:	    state->deckCount[nextPlayer]++;
-1 	857:	    state->discard[nextPlayer][i] = -1;
-1 	858:	    state->discardCount[nextPlayer]--;
-1 	859:	  }
-1 	860:			    
-1 	861:	  shuffle(nextPlayer,state);//Shuffle the deck
-1 	862:	} 
-1 	863:	tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
-1 	864:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
-1 	865:	state->deckCount[nextPlayer]--;
-1 	866:	tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
-1 	867:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
-1 	868:	state->deckCount[nextPlayer]--;
-1 	869:      }    
-1 	870:		       
-1 	871:      if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
-1 	872:	state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
-1 	873:	state->playedCardCount++;
-1 	874:	tributeRevealedCards[1] = -1;
-1 	875:      }
-1 	876:
-1 	877:      for (i = 0; i <= 2; i ++){
-1 	878:	if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
-1 	879:	  state->coins += 2;
-1 	880:	}
-1 	881:		    
-1 	882:	else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
-1 	883:	  drawCard(currentPlayer, state);
-1 	884:	  drawCard(currentPlayer, state);
-1 	885:	}
-1 	886:	else{//Action Card
-1 	887:	  state->numActions = state->numActions + 2;
-1 	888:	}
-1 	889:      }
-1 	890:	    
-1 	891:      return 0;
-1 	892:		
-1 	893:    case ambassador:
-1 	894:      j = 0;		//used to check if player has enough cards to discard
-1 	895:
-1 	896:      if (choice2 > 2 || choice2 < 0)
-1 	897:	{
-1 	898:	  return -1;				
-1 	899:	}
-1 	900:
-1 	901:      if (choice1 == handPos)
-1 	902:	{
-1 	903:	  return -1;
-1 	904:	}
-1 	905:
-1 	906:      for (i = 0; i < state->handCount[currentPlayer]; i++)
-1 	907:	{
-1 	908:	  if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
-1 	909:	    {
-1 	910:	      j++;
-1 	911:	    }
-1 	912:	}
-1 	913:      if (j < choice2)
-1 	914:	{
-1 	915:	  return -1;				
-1 	916:	}
-1 	917:
-1 	918:      if (DEBUG) 
-1 	919:	printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
-1 	920:
-1 	921:      //increase supply count for choosen card by amount being discarded
-1 	922:      state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
-1 	923:			
-1 	924:      //each other player gains a copy of revealed card
-1 	925:      for (i = 0; i < state->numPlayers; i++)
-1 	926:	{
-1 	927:	  if (i != currentPlayer)
-1 	928:	    {
-1 	929:	      gainCard(state->hand[currentPlayer][choice1], state, 0, i);
-1 	930:	    }
-1 	931:	}
-1 	932:
-1 	933:      //discard played card from hand
-1 	934:      discardCard(handPos, currentPlayer, state, 0);			
-1 	935:
-1 	936:      //trash copies of cards returned to supply
-1 	937:      for (j = 0; j < choice2; j++)
-1 	938:	{
-1 	939:	  for (i = 0; i < state->handCount[currentPlayer]; i++)
-1 	940:	    {
-1 	941:	      if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
-1 	942:		{
-1 	943:		  discardCard(i, currentPlayer, state, 1);
-1 	944:		  break;
-1 	945:		}
-1 	946:	    }
-1 	947:	}			
-1 	948:
-1 	949:      return 0;
-1 	950:		
-1 	951:    case cutpurse:
-1 	952:
-1 	953:      updateCoins(currentPlayer, state, 2);
-1 	954:      for (i = 0; i < state->numPlayers; i++)
-1 	955:	{
-1 	956:	  if (i != currentPlayer)
-1 	957:	    {
-1 	958:	      for (j = 0; j < state->handCount[i]; j++)
-1 	959:		{
-1 	960:		  if (state->hand[i][j] == copper)
-1 	961:		    {
-1 	962:		      discardCard(j, i, state, 0);
-1 	963:		      break;
-1 	964:		    }
-1 	965:		  if (j == state->handCount[i])
-1 	966:		    {
-1 	967:		      for (k = 0; k < state->handCount[i]; k++)
-1 	968:			{
-1 	969:			  if (DEBUG)
-1 	970:			    printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
-1 	971:			}	
-1 	972:		      break;
-1 	973:		    }		
-1 	974:		}
-1 	975:					
-1 	976:	    }
-1 	977:				
-1 	978:	}				
-1 	979:
-1 	980:      //discard played card from hand
-1 	981:      discardCard(handPos, currentPlayer, state, 0);			
-1 	982:
-1 	983:      return 0;
-1 	984:
-1 	985:		
-1 	986:    case embargo: 
-1 	987:      //+2 Coins
-1 	988:      state->coins = state->coins + 2;
-1 	989:			
-1 	990:      //see if selected pile is in play
-1 	991:      if ( state->supplyCount[choice1] == -1 )
-1 	992:	{
-1 	993:	  return -1;
-1 	994:	}
-1 	995:			
-1 	996:      //add embargo token to selected supply pile
-1 	997:      state->embargoTokens[choice1]++;
-1 	998:			
-1 	999:      //trash card
-1 	1000:      discardCard(handPos, currentPlayer, state, 1);		
-1 	1001:      return 0;
-1 	1002:		
-1 	1003:    case outpost:
-1 	1004:      //set outpost flag
-1 	1005:      state->outpostPlayed++;
-1 	1006:			
-1 	1007:      //discard card
-1 	1008:      discardCard(handPos, currentPlayer, state, 0);
-1 	1009:      return 0;
-1 	1010:		
-1 	1011:    case salvager:
-1 	1012:      //+1 buy
-1 	1013:      state->numBuys++;
-1 	1014:			
-1 	1015:      if (choice1)
-1 	1016:	{
-1 	1017:	  //gain coins equal to trashed card
-1 	1018:	  state->coins = state->coins + getCost( handCard(choice1, state) );
-1 	1019:	  //trash card
-1 	1020:	  discardCard(choice1, currentPlayer, state, 1);	
-1 	1021:	}
-1 	1022:			
-1 	1023:      //discard card
-1 	1024:      discardCard(handPos, currentPlayer, state, 0);
-1 	1025:      return 0;
-1 	1026:		
-1 	1027:    case sea_hag:
-1 	1028:      for (i = 0; i < state->numPlayers; i++){
-1 	1029:	if (i != currentPlayer){
-1 	1030:	  state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
-1 	1031:	  state->discardCount[i]++;
-1 	1032:	  state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
-1 	1033:	}
-1 	1034:      }
-1 	1035:      return 0;
-1 	1036:		
-1 	1037:    case treasure_map:
-1 	1038:      //search hand for another treasure_map
-1 	1039:      index = -1;
-1 	1040:      for (i = 0; i < state->handCount[currentPlayer]; i++)
-1 	1041:	{
-1 	1042:	  if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
-1 	1043:	    {
-1 	1044:	      index = i;
-1 	1045:	      break;
-1 	1046:	    }
-1 	1047:	}
-1 	1048:      if (index > -1)
-1 	1049:	{
-1 	1050:	  //trash both treasure cards
-1 	1051:	  discardCard(handPos, currentPlayer, state, 1);
-1 	1052:	  discardCard(index, currentPlayer, state, 1);
-1 	1053:
-1 	1054:	  //gain 4 Gold cards
-1 	1055:	  for (i = 0; i < 4; i++)
-1 	1056:	    {
-1 	1057:	      gainCard(gold, state, 1, currentPlayer);
-1 	1058:	    }
-1 	1059:				
-1 	1060:	  //return success
-1 	1061:	  return 1;
-1 	1062:	}
-1 	1063:			
-1 	1064:      //no second treasure_map found in hand
-1 	1065:      return -1;
-1 	1066:    }
-1 	1067:	
-1 	1068:  return -1;
-1 	1069:}
-1 	1070:
-1 	1071:int adventurerEffect(struct gameState *state, int handPos) {
-1 	1072:   int i, currentPlayer = whoseTurn(state);
-1 	1073:   int temphand[MAX_HAND];
-1 	1074:   int drawntreasure = 0;
-1 	1075:   int cardDrawn;
-1 	1076:   int topCard;
-1 	1077:   int totDeck; // counter for total cards in deck
-1 	1078:   int totDiscard; // counter for total cards in discard
-1 	1079:   int y = 0; // counter for the shuffle
-1 	1080:   int z = 0; // counter for temp hand
-1 	1081:
-1 	1082:   totDeck = state->deckCount[currentPlayer];
-1 	1083:   totDiscard = state->discardCount[currentPlayer];
-1 	1084:
-1 	1085:   while((drawntreasure < 2) && ((totDeck + totDiscard) != 0)) {
-1 	1086:      // if the deck is empty, we need to shuffle discard and add to deck
-1 	1087:      if(totDeck < 1) {
-1 	1088:         shuffle(currentPlayer, state);
-1 	1089:      }
-1 	1090:      drawCard(currentPlayer, state);
-1 	1091:      // top card is most recently drawn card
-1 	1092:      topCard = state->handCount[currentPlayer] - 1;
-1 	1093:      cardDrawn = state->hand[currentPlayer][topCard];
-1 	1094:      if(cardDrawn == copper || cardDrawn == silver || cardDrawn == gold) {
-1 	1095:         drawntreasure++;
-1 	1096:      }
-1 	1097:      else {
-1 	1098:         temphand[z] = cardDrawn;
-1 	1099:         // remove the top card (the most recently drawn one)
-1 	1100:         state->handCount[currentPlayer]--;
-1 	1101:         z++;
-1 	1102:      }
-1 	1103:      totDeck = state->deckCount[currentPlayer];
-1 	1104:      totDiscard = state->discardCount[currentPlayer];
-1 	1105:   }
-1 	1106:   // discard all non-treasure cards that have been drawn
-1 	1107:   while((z - 1) >= 0) {
-1 	1108:      topCard = state->discardCount[currentPlayer];
-1 	1109:      state->discard[currentPlayer][topCard++] = temphand[z - 1];
-1 	1110:      state->discardCount[currentPlayer] = topCard;
-1 	1111:      z = z - 1;
-1 	1112:   }
-1 	1113:   // discard the adventurer card from hand
-1 	1114:   discardCard(handPos, currentPlayer, state, 0);
-1 	1115:
-1 	1116:   return 0;
-1 	1117:}
-1 	1118:
-1 	1119:// smithy allows a player to draw 3 cards
-1 	1120:int smithyEffect(struct gameState *state, int handPos) {
-1 	1121:   int currentPlayer = whoseTurn(state);
-1 	1122:   int i;
-1 	1123:
-1 	1124:   for(i = 0; i < 3; i++) {
-1 	1125:      drawCard(currentPlayer, state);
-1 	1126:   }
-1 	1127:   return 0;
-1 	1128:}
-1 	1129:
-1 	1130:// feast allows you to gain a card with a cost up to 5
-1 	1131:int feastEffect(int choice, struct gameState *state, int handPos) {
-1 	1132:   int currentPlayer = whoseTurn(state);
-1 	1133:   int cardCountHand;
-1 	1134:   int cardCountDeck;
-1 	1135:   int cardCountDiscard;
-1 	1136:   int cardCountTotal;
-1 	1137:
-1 	1138:   // Update coins for buy
-1 	1139:   updateCoins(currentPlayer, state, 5);
-1 	1140:   // Buy one card
-1 	1141:   if(supplyCount(choice, state) <= 0) {
-1 	1142:      if(DEBUG) {
-1 	1143:         printf("Cards Left: %d\n", supplyCount(choice, state));
-1 	1144:      }
-1 	1145:      return -1;
-1 	1146:   }
-1 	1147:   else if(state->coins < getCost(choice)) {
-1 	1148:      if(DEBUG) {
-1 	1149:         printf("Coins: %d < %d\n", state->coins, getCost(choice));
-1 	1150:      }
-1 	1151:      return -1;
-1 	1152:   }
-1 	1153:   else {
-1 	1154:      if(DEBUG) {
-1 	1155:         cardCountHand = state->handCount[currentPlayer];
-1 	1156:         cardCountDeck = state->deckCount[currentPlayer];
-1 	1157:         cardCountDiscard = state->discardCount[currentPlayer];
-1 	1158:         cardCountTotal = cardCountHand + cardCountDeck + cardCountDiscard;
-1 	1159:         printf("Deck Count: %d\n", cardCountTotal);
-1 	1160:      }
-1 	1161:      // discard and trash the feast card
-1 	1162:      discardCard(handPos, currentPlayer, state, 1);
-1 	1163:
-1 	1164:      gainCard(choice, state, 0, currentPlayer); // Gain the card
-1 	1165:
-1 	1166:      if(DEBUG) { 
-1 	1167:         cardCountHand = state->handCount[currentPlayer];
-1 	1168:         cardCountDeck = state->deckCount[currentPlayer];
-1 	1169:         cardCountDiscard = state->discardCount[currentPlayer];
-1 	1170:         cardCountTotal = cardCountHand + cardCountDeck + cardCountDiscard;
-1 	1171:         printf("Deck Count: %d\n", cardCountTotal);
-1 	1172:      }
-1 	1173:   }
-1 	1174:   return 0;
-1 	1175:}
-1 	1176:
-1 	1177:// Minion is a +1 action card
-1 	1178:int minionEffect(int choice1, int choice2, struct gameState *state, int handPos)
-1 	1179:{
-1 	1180:   int i;
-1 	1181:   int j;
-1 	1182:   int currentPlayer = whoseTurn(state);
-1 	1183:
-1 	1184:   state->numActions++;
-1 	1185:
-1 	1186:   // discard card from hand
-1 	1187:   discardCard(handPos, currentPlayer, state, 0);
-1 	1188:
-1 	1189:   // if the player chooses the +2 coins option
-1 	1190:   if(choice1) {
-1 	1191:      state->coins = state->coins + 2;
-1 	1192:   }
-1 	1193:
-1 	1194:   // if the players chooses to discard hand, redraw 4, and other players with
-1 	1195:   // 5+ cards discard hand and draw 4
-1 	1196:   else if(choice2) {
-1 	1197:      // discard hand
-1 	1198:      while(numHandCards(state) > 0) {
-1 	1199:         discardCard(handPos, currentPlayer, state, 0);
-1 	1200:      }
-1 	1201:      // draw 4
-1 	1202:      for(i = 0; i < 4; i++) {
-1 	1203:         drawCard(currentPlayer, state);
-1 	1204:      }
-1 	1205:      // other players discard hand redraw if hand size > 4
-1 	1206:      for(i = 0; i < state->numPlayers; i++) {
-1 	1207:         if((i != currentPlayer) && ((state->handCount[i]) > 4)) {
-1 	1208:            // discard hand
-1 	1209:            while(state->handCount[i] > 0) {
-1 	1210:               discardCard(handPos, i, state, 0);
-1 	1211:            }
-1 	1212:            // draw 4
-1 	1213:            for(j = 0; j < 4; j++) {
-1 	1214:               drawCard(i, state);
-1 	1215:            }
-1 	1216:         }
-1 	1217:      }
-1 	1218:   }
-1 	1219:   return 0;
-1 	1220:}
-1 	1221:
0.871886120996 	1222:int mineEffect(int choice1, int choice2, struct gameState *state, int handPos) 
-1 	1223:{
-1 	1224:   int i;
0.871886120996 	1225:   int currentPlayer = whoseTurn(state);
0.871886120996 	1226:   int j = state->hand[currentPlayer][choice1]; // store card we will trash
-1 	1227:
0.871886120996 	1228:   if((state->hand[currentPlayer][choice1] < copper) ||
0.880107768298 	1229:      (state->hand[currentPlayer][choice1] > gold)) {
0.0 	1230:      return -1;
-1 	1231:   }
0.937350549976 	1232:   if((choice2 > treasure_map) || (choice2 < curse)) {
0.0 	1233:      return -1;
-1 	1234:   }
0.950072709646 	1235:   if((getCost(state->hand[currentPlayer][choice1]) + 3) < getCost(choice2)) {
0.0 	1236:      return -1;
-1 	1237:   }
0.957498778701 	1238:   gainCard(choice2, state, 2, currentPlayer);
-1 	1239:
-1 	1240:   // discard card from hand
0.957498778701 	1241:   discardCard(handPos, currentPlayer, state, 0);
-1 	1242:
-1 	1243:   // discard trashed card
0.957498778701 	1244:   for(i = 0; i < (state->handCount[currentPlayer]); i++) {
0.957498778701 	1245:      if((state->hand[currentPlayer][i]) == j) {
0.957498778701 	1246:         discardCard(i, currentPlayer, state, 1);
0.957498778701 	1247:         break;
-1 	1248:      }
-1 	1249:   }
0.957498778701 	1250:   return 0;
-1 	1251:}
-1 	1252:
0.957498778701 	1253:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
-1 	1254:{
-1 	1255:	
-1 	1256:  //if card is not trashed, added to Played pile 
0.957498778701 	1257:  if (trashFlag < 1)
-1 	1258:    {
-1 	1259:      //add card to played pile
0.957498778701 	1260:      state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos]; 
0.957498778701 	1261:      state->playedCardCount++;
-1 	1262:    }
-1 	1263:	
-1 	1264:  //set played card to -1
0.957498778701 	1265:  state->hand[currentPlayer][handPos] = -1;
-1 	1266:	
-1 	1267:  //remove card from player's hand
0.957498778701 	1268:  if ( handPos == (state->handCount[currentPlayer] - 1) ) 	//last card in hand array is played
-1 	1269:    {
-1 	1270:      //reduce number of cards in hand
0.98 	1271:      state->handCount[currentPlayer]--;
-1 	1272:    }
0.956456456456 	1273:  else if ( state->handCount[currentPlayer] == 1 ) //only one card in hand
-1 	1274:    {
-1 	1275:      //reduce number of cards in hand
-1 	1276:      state->handCount[currentPlayer]--;
-1 	1277:    }
-1 	1278:  else 	
-1 	1279:    {
-1 	1280:      //replace discarded card with last card in hand
0.956456456456 	1281:      state->hand[currentPlayer][handPos] = state->hand[currentPlayer][ (state->handCount[currentPlayer] - 1)];
-1 	1282:      //set last card to -1
0.956456456456 	1283:      state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
-1 	1284:      //reduce number of cards in hand
0.956456456456 	1285:      state->handCount[currentPlayer]--;
-1 	1286:    }
-1 	1287:	
0.957498778701 	1288:  return 0;
-1 	1289:}
-1 	1290:
0.957498778701 	1291:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
-1 	1292:{
-1 	1293:  //Note: supplyPos is enum of choosen card
-1 	1294:	
-1 	1295:  //check if supply pile is empty (0) or card is not used in game (-1)
0.957498778701 	1296:  if ( supplyCount(supplyPos, state) < 1 )
-1 	1297:    {
1.0 	1298:      return -1;
-1 	1299:    }
-1 	1300:	
-1 	1301:  //added card for [whoseTurn] current player:
-1 	1302:  // toFlag = 0 : add to discard
-1 	1303:  // toFlag = 1 : add to deck
-1 	1304:  // toFlag = 2 : add to hand
-1 	1305:
0.951720310766 	1306:  if (toFlag == 1)
-1 	1307:    {
-1 	1308:      state->deck[ player ][ state->deckCount[player] ] = supplyPos;
-1 	1309:      state->deckCount[player]++;
-1 	1310:    }
0.951720310766 	1311:  else if (toFlag == 2)
-1 	1312:    {
0.951720310766 	1313:      state->hand[ player ][ state->handCount[player] ] = supplyPos;
0.951720310766 	1314:      state->handCount[player]++;
-1 	1315:    }
-1 	1316:  else
-1 	1317:    {
-1 	1318:      state->discard[player][ state->discardCount[player] ] = supplyPos;
-1 	1319:      state->discardCount[player]++;
-1 	1320:    }
-1 	1321:	
-1 	1322:  //decrease number in supply pile
0.951720310766 	1323:  state->supplyCount[supplyPos]--;
-1 	1324:	 
0.951720310766 	1325:  return 0;
-1 	1326:}
-1 	1327:
0.957498778701 	1328:int updateCoins(int player, struct gameState *state, int bonus)
-1 	1329:{
-1 	1330:  int i;
-1 	1331:	
-1 	1332:  //reset coin count
0.957498778701 	1333:  state->coins = 0;
-1 	1334:
-1 	1335:  //add coins for each Treasure card in player's hand
0.957498778701 	1336:  for (i = 0; i < state->handCount[player]; i++)
-1 	1337:    {
0.957498778701 	1338:      if (state->hand[player][i] == copper)
-1 	1339:	{
0.940499040307 	1340:	  state->coins += 1;
-1 	1341:	}
0.958904109589 	1342:      else if (state->hand[player][i] == silver)
-1 	1343:	{
0.953982300885 	1344:	  state->coins += 2;
-1 	1345:	}
0.963144963145 	1346:      else if (state->hand[player][i] == gold)
-1 	1347:	{
0.945945945946 	1348:	  state->coins += 3;
-1 	1349:	}	
-1 	1350:    }	
-1 	1351:
-1 	1352:  //add bonus
0.957498778701 	1353:  state->coins += bonus;
-1 	1354:
0.957498778701 	1355:  return 0;
-1 	1356:}
-1 	1357:
-1 	1358:
-1 	1359://end of dominion.c
